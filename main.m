% 这一版是自己参照mutual guide随机选择数据来训练，效果不好% 后来是修改为给每个类别一个筛选比例，这样数据少的部分也能多选些数据了clc;clear;close alladdpath('.\libsvm-3.21\matlab');addpath(genpath(cd));num_PC           =   50;  % THE OPTIMAL PCA DIMENSION.% num_Pixel        =   100; % THE OPTIMAL Number of Superpixel. Indian:100, PaviaU:20, Salinas:100iterNum          =   5;  % The Iteration Number% 训练数据占总数居的比例percentage       = 0.15;database         =   'Indian';%% load the HSI datasetif strcmp(database,'Indian')    load Indian_pines_corrected;load Indian_pines_gt;load Indian_pines_randp     data3D = indian_pines_corrected;        label_gt = indian_pines_gt;    num_Pixel        =   100;    num_PC           =   50;    class            =   16;    for p = 1:class        percentage(p) = 0.15;    end%     percentage       =[0.15,0.1,0.15,0.15,0.15,0.15,0.15,0.05,0.5,0.05,0.035,0.05,0.05,0.04,0.05,0.2]; elseif strcmp(database,'Salinas')    load Salinas;load Salinas_gt;load Salinas_randp    data3D = salinas;        label_gt = salinas_gt;    num_Pixel        =   100;    num_PC           =   50;    class            =   16;    for p = 1:class        percentage(p) = 0.05;    endelseif strcmp(database,'PaviaU')        load PaviaU;load PaviaU_gt;load PaviaU_randp;     data3D = paviaU;        label_gt = paviaU_gt;   label_gt = double(label_gt);    num_Pixel        =   23;    num_PC           =   50;     class            =   9;    for p = 1:class        percentage(p) = 0.05;    end    % 97.5 to 97.84enddata3D = data3D./max(data3D(:));%% super-pixels segmentationlabels = cubseg(data3D,num_Pixel);%% SupePCA% [dataDR] = SuperPCA(data3D,num_PC,labels);dataDR = data3D;b = size(dataDR);data_transfer = reshape(dataDR, b(1)*b(2), b(3)); % 21025x50 doublelabel_transfer = reshape(label_gt, [], 1); % 21025x1 double% 除去数据中的背景数据dataSVM = []; labelSVM = [];prospect = find((label_transfer ~= 0));dataSVM = [dataSVM; data_transfer(prospect, :)];  % 10249x50 doublelabelSVM = [labelSVM; label_transfer(prospect)];  % 10249x1 doublelabelSVM = double(labelSVM);% 数据总量b = size(dataSVM);data_sum = b(1);% 这里不能转成int16类型，在数据切片的时候这个类型不识别trainNum = round(data_sum * percentage);% 每次迭代后添加的数据量addPercentage = 0.005;addNum = round(data_sum * addPercentage);fileID=fopen('record_test.txt','w'); %% 开始训练% iterNum          =   2; % 记录数据best_accracy = 0;for iter = 1:iterNum        % SVM    if iter == 1        % 首次训练，分别制作训练集，但数据一样                trainlabel1 = [];        DataTrain1 = [];        % 按类别选择训练数据        for c = 1: class            prospect = find((labelSVM == c));%             class_size = size(prospect,1)             data_class = dataSVM(prospect, :);            label_class = labelSVM(prospect, :);            % 随机选取5%的行号            data_size = size(data_class,1);            prospect = randperm(data_size, round(data_size * percentage(c)));            DataTrain1 = [DataTrain1; data_class(prospect, :)];            trainlabel1 = [trainlabel1; label_class(prospect, :)];                    end                trainlabel2 = trainlabel1;        DataTrain2 = DataTrain1;           end            % 模型一    % set the para of RBF        train_size = size(DataTrain1)    ga8 = [0.01 0.1 1 5 10];    ga9 = [15 20 30 40 50 100:100:500];    GA = [ga8,ga9];    tempaccuracy = 0;    best_predict = [];    best_values = [];    for trial0 = 1:length(GA)           gamma = GA(trial0);                cmd = ['-q -c 100000 -g ' num2str(gamma) ' -b 1'];        model = svmtrain(trainlabel1, DataTrain1, cmd);        % 使用全部数据做测试        [predict_label, AC, prob_values] = svmpredict(labelSVM, dataSVM, model, '-b 1 -q');           if AC(1) > tempaccuracy            tempaccuracy = AC(1);            if tempaccuracy > best_accracy                best_model = model;                best_accracy = tempaccuracy;            end            best_predict = predict_label; % size(predict_label)  1  42416               best_values = prob_values;        end    end    fprintf(['--------------iter %d,1, accuracy is %0.4f\n'],iter,tempaccuracy);    [OA_A,Kappa_A,producerA_A] = CalAccuracy(best_predict', labelSVM);    producerA_A    AA_A = mean(producerA_A(:));    fprintf('   ... ... The final OA, AA, and Kappa of classifier A are %f, %f, %f ... ...\n', OA_A, AA_A, Kappa_A);%     fprintf('   ... ... The OA, AA, and Kappa of classifier A are %f, %f, %f ... ...\n', OA_A, Kappa_A, Kappa_A);%     max(result)%     min(result)%     max(labelSVM) 10249x1 double    % 筛选置信度高的数据    data_sum = size(dataSVM, 1);    select_label = [];    select_data = [];    %     min(best_predict)%     max(best_predict)    for i = 1:data_sum        if best_predict(i,1) == labelSVM(i,1) && best_values(i,best_predict(i,1)) > 0.9            select_label = [select_label; best_predict(i,1)];            select_data = [select_data; dataSVM(i,:)];        end    end 	s = size(select_label);  %        39645           1%     size(select_data)  39645          50%   从测试集中抽取小部分训练集    index = randperm(s(1), addNum)';    trainlabel_select1 = select_label(index, :);    DataTrain_select1 = select_data(index, :);%     size(DataTrain_select1) PaviaU   214    50            %-------------------- 模型二-------------------------------------------        ga8 = [0.01 0.1 1 5 10];    ga9 = [15 20 30 40 50 100:100:500];    GA = [ga8,ga9];%     accy = zeros(1,length(GA));    tempaccuracy = 0;    best_predict = [];    best_values = [];    for trial0 = 1:length(GA);            gamma = GA(trial0);                 % kenerl: 多项式：(r*u'v + coef0)^degree        cmd = ['-q -c 100000 -g ' num2str(gamma) ' -b 1 -t 1'];% -t 改变了核函数类型        model = svmtrain(trainlabel2, DataTrain2, cmd);        % 使用全部数据做测试        [predict_label, AC, prob_values] = svmpredict(labelSVM, dataSVM, model, '-b 1 -q');   %         size(predict_label)%         AC%         size(prob_values)        % [confusion, accuracy1, CR, FR] = confusion_matrix(predict_label', CTest);        if AC(1) > tempaccuracy            tempaccuracy = AC(1);            if tempaccuracy > best_accracy                best_model = model;                best_accracy = tempaccuracy;            end            best_predict = predict_label; % size(predict_label)  1  42416               best_values = prob_values;        end    end    fprintf(['--------------iter %d,2, accuracy is %0.4f\n'],iter,tempaccuracy);%     max(result)%     min(result)%     max(labelSVM) 10249x1 double    % 筛选置信度高的数据    data_sum = size(dataSVM, 1);    select_label = [];    select_data = [];%     best_predict(1,20)    for i = 1:data_sum        if best_predict(i,1) == labelSVM(i,1) && best_values(i,best_predict(i,1)) > 0.9            select_label = [select_label; best_predict(i,1)];            select_data = [select_data; dataSVM(i,:)];        end    end 	s = size(select_label);  %        39645           1%     size(select_data)  39645          50%   从测试集中抽取小部分训练集    index = randperm(s(1), addNum)';    trainlabel_select2 = select_label(index, :);    DataTrain_select2 = select_data(index, :);%     size(DataTrain_select1) PaviaU   214    50        %************************************%      fprintf(fileID,'iter: %d, SVM acc is %.4f\n',iter,max(accy));      %************************************                    % 添加SVM的训练集    % 模型一的测试数据添加到模型二的训练数据中    DataTrain2 = [DataTrain2; DataTrain_select1];    trainlabel2 = [trainlabel2; trainlabel_select1];    new_train_label_size = size(trainlabel2);        % 模型二的测试数据添加到模型一的训练数据中    DataTrain1 = [DataTrain1; DataTrain_select2];    trainlabel1 = [trainlabel1; trainlabel_select2];endfclose(fileID); % fprintf('\n=============================================================\n');% fprintf(['The average OA (10 iterations) of SuperPCA for ',database,' is %0.4f\n'],mean(accy_best));% fprintf('=============================================================\n');% 生成可视化图片[M,N,D] = size(dataDR);figure = zeros(M,N);% predict_label =%      9% prob_values =%     0.0233    0.0086    0.0026    0.0063    0.0021    0.0013    0.0029    0.0035    0.9494acc_sum = 0; num = 0;for i = 1:M    for j = 1:N        [predict_label, AC, prob_values] = svmpredict(label_gt(i,j), dataDR(i,j,:), best_model, '-b 1 -q');         if label_gt(i,j) ~= 0            figure(i,j) = predict_label;            acc_sum = acc_sum + prob_values(predict_label);            num = num + 1;%             min2 = min(min2, prob_values(predict_label));%         else%             max1 = max(max1, max(prob_values));        end    endendnumaverage_sum = acc_sum/num;fprintf('\n=============================================================\n');fprintf(['The average OA (10 iterations) for ',database,' is %0.4f\n'],average_sum);fprintf('=============================================================\n');%% 边缘点% imshow(figure*20/255);% disp(['（使用第一个模型测试整个数据集并展示结果） ' ])im = imagesc(figure);[Data_edge, label_polar] = polar(dataDR, label_gt);s = size(Data_edge);num = zeros(1, 17);sum = zeros(1, 17);for i = 1:s(1)    if label_polar(i) == 0        continue    end%     [predict_label, AC, prob_values] = svmpredict(label_gt(i,j), dataDR(i,j,:), best_model, '-b 1 -q');    [predict_label, AC, prob_values] = svmpredict(label_polar(i), Data_edge(i,:), best_model, '-b 1 -q');       if label_polar(i) == predict_label        num(label_polar(i)) = num(label_polar(i)) + 1;    end    sum(label_polar(i)) = sum(label_polar(i)) + 1;endfor i = 1:17    fprintf(['edge for %d is %0.4f\n'],i, num(i)/sum(i));end